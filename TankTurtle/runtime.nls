;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Runtime Procedures ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

to input-player  ;; Observer Procedure
  ask players
  [
    ;; move forward unless blocked
    let old-heading heading
    set heading new-heading
    if [pcolor] of patch-ahead 1 != black
    [ set heading old-heading ]
    if [pcolor] of patch-ahead 1 = black
    [ fd 1 ]
    player-collisions ;; check for player collisions with other turtles
  ]
end

to input-bots  ; Observer Procedure
  ask bots
  [
    ;; move/fire
  ]
end

to player-collisions  ; Turtle Procedure
;  ;; Check for other turtles occupying the same patch as the player
;  if any? fuels-here ;; is the turtle a fuel
;  [
;    ;; clamp fuel between 0 and 100
;    set fuel median (list 0 (fuel + 50) 100)
;  ]
;  if any? ammos here ;; is the turtle an ammo
;  [
;    set ammo ammo + 5
;  ]
;  if any? bullets here ;; is the turtle a bullet
;  [
;    set lives lives - 1
;  ]
end


; set destination
to set-destination ; Turtle procedure
  ask players
  [
    if state = "looking for player"
    [
    ]
  ]
end

; find shortest path to destination



; move to next patch in patch
to move-to-next-patch-in-current-path
  ask bots 
  [
    face first current-path
    repeat 10
    [
      fd 0.1
    ]
    move-to first current-path
    ; if distance from this turtle to the player is less than range & clear line of sight, then
    ;if distance-to-player
  ]
end

to can-shoot-player ; bot procedure
  ask bots
  [
    ; check if the closest player is within firing range
    if (distance min-one-of players[distance myself] < range)
    [
      ; check if player is in LOS
      if player-in-LOS?
      [
        ; fire
      ]
    ]
  ]
end

to-report player-in-LOS? ; bot procedure
  ; if no obstacles between bot and player, then LOS is true
  ;report min-one-of players[distance myself] 'isInLOS'true/false
  report true
end

to find-shortest-path-to-destination
  reset-ticks
  ask one-of turtles 
  [
    move-to one-of patches with [plabel = "source"]
    set path find-a-path one-of patches with [plabel = "source"] one-of patches with [plabel = "destination"]
    set optimal-path path
    set current-path path
  ]
  output-show (word "Shortest path length : " length optimal-path)
  move
end

to-report find-a-path [ source-patch destination-patch] 
  
  ; initialize all variables to default values
  let search-done? false
  let search-path []
  let current-patch 0
  set open []
  set closed []  
  
  ; add source patch in the open list
  set open lput source-patch open
  
  ; loop until we reach the destination or the open list becomes empty
  while [ search-done? != true]
  [    
    ifelse length open != 0
    [
      ; sort the patches in open list in increasing order of their f() values
      set open sort-by [[f] of ?1 < [f] of ?2] open
      
      ; take the first patch in the open list
      ; as the current patch (which is currently being explored (n))
      ; and remove it from the open list
      set current-patch item 0 open 
      set open remove-item 0 open
      
      ; add the current patch to the closed list
      set closed lput current-patch closed
      
      ; explore the Von Neumann (left, right, top and bottom) neighbors of the current patch
      ask current-patch
      [         
        ; if any of the neighbors is the destination stop the search process
        ifelse any? neighbors4 with [ (pxcor = [ pxcor ] of destination-patch) and (pycor = [pycor] of destination-patch)]
        [
          set search-done? true
        ]
        [
          ; the neighbors should not be obstacles or already explored patches (part of the closed list)          
          ask neighbors4 with [ pcolor != white and (not member? self closed) and (self != parent-patch) ]     
          [
            ; the neighbors to be explored should also not be the source or 
            ; destination patches or already a part of the open list (unexplored patches list)
            if not member? self open and self != source-patch and self != destination-patch
            [
              set pcolor 45
              
              ; add the eligible patch to the open list
              set open lput self open
              
              ; update the path finding variables of the eligible patch
              set parent-patch current-patch 
              set g [g] of parent-patch  + 1
              set h distance destination-patch
              set f (g + h)
            ]
          ]
        ]
        if self != source-patch
        [
          set pcolor 35
        ]
      ]
    ]
    [
      ; if a path is not found (search is incomplete) and the open list is exhausted 
      ; display a user message and report an empty search path list.
      user-message( "A path from the source to the destination does not exist." )
      report []
    ]
  ]
  
  ; if a path is found (search completed) add the current patch 
  ; (node adjacent to the destination) to the search path.
  set search-path lput current-patch search-path
  
  ; trace the search path from the current patch 
  ; all the way to the source patch using the parent patch
  ; variable which was set during the search for every patch that was explored
  let temp first search-path
  while [ temp != source-patch ]
  [
    ask temp
    [
      set pcolor 85
    ]
    set search-path lput [parent-patch] of temp search-path 
    set temp [parent-patch] of temp
  ]
  
  ; add the destination patch to the front of the search path
  set search-path fput destination-patch search-path
  
  ; reverse the search path so that it starts from a patch adjacent to the
  ; source patch and ends at the destination patch
  set search-path reverse search-path  

  ; report the search path
  report search-path
end

; make the turtle traverse (move through) the path all the way to the destination patch
to move
  ask one-of turtles 
  [
    while [length current-path != 0]
    [
      go-to-next-patch-in-current-path
      pd
      wait 0.05
    ]
    if length current-path = 0
    [
      pu
    ]
  ]   
end

to go-to-next-patch-in-current-path  
  face first current-path
  repeat 10
  [
    fd 0.1
  ]
  move-to first current-path
  if [plabel] of patch-here != "source" and  [plabel] of patch-here != "destination"
  [
    ask patch-here
    [
      set pcolor black
    ]
  ]
  set current-path remove-item 0 current-path
end