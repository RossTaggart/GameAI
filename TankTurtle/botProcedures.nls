;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;     Bot Procedures     ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to update-states ;; this is going to be the defined states which tell the tank what to do ;; Basic version of game will only have 3 states - idle, attacking and seeking
  
  ;; this is the state that the enemy tank will begin in at setup
  if current-enemy-state = "idle"
  [ set current-enemy-state "seeking"]
  
  ;; this state is for when the enemy can neither see nor is near the player
    if current-enemy-state = "seeking"
    [ 
      if length current-path < 2
      [
        set destination one-of patches with [pcolor = white and distance myself > 15]
      ]
      move-bot 
    ]
    
    if current-enemy-state = "chasing"
    [
      set destination one-of players
      move-bot
    ]
  
  ;; this state is for when the enemy tank is within "x" blocks of the player and can see him
    if current-enemy-state = "attacking"
    [
      face player 0
      ask bots
      [
        set enemy-can-shoot?  true
        stop
      ]
    ]
    
    if current-enemy-state = "low-ammo"
    [
      let closest-ammo min-one-of ammos [distance myself]
      set destination closest-ammo
      move-bot
     ;;seek da ammos 
    ]
  
  ;; when the player hits the enemy it will set the enemy state to dead
    if current-enemy-state = "dead"
      [ user-message "YOU WON, YOU WINNER"   toggleendgame ]
end

to revert-to-seeking
  if current-enemy-state != "seeking"
  [
    set current-enemy-state "seeking"
    set destination one-of patches with [pcolor = white and distance myself > 15]
  ]
end

to check-current-state ;; this is going to be the transitions between states
  
  ;; if the enemy leavesthe attack state
  if current-enemy-state != "attacking"
  [
    set enemy-can-shoot? false
  ]
  
  ;;if the bot has no health - die
  if enemyHealth = 0
  [
    set current-enemy-state "dead"
    stop
  ]
  
  ;; if the bot is low on ammo - seek ammo instead of player
  if enemyAmmo = 0
  [
   set current-enemy-state "low-ammo" 
   stop
  ]
  
  ;; if the player is in attacking distance- stops enemy and gets ready to fire
  if [distance myself] of one-of patches with [any? players-here] < 5
    [
      set current-enemy-state "attacking"
      stop  
    ]
  ;; if the player is in chasing distance- gives the enemy the players exact location
  if [distance myself] of one-of patches with [any? players-here] < 10
  [
    set current-enemy-state "chasing"
    stop
  ]
  
  ;; player has went back out of attacking/chasing range
  if length current-path > 5
    [revert-to-seeking set debug-state "out of range"]  
end

to input-bots  ; Observer Procedure
  find-shortest-path-to-destination
  ask bots
  [
    if [distance myself] of one-of patches with [any? players-here] != 1;; if the enemy tank has not caught the player
    [
      check-current-state
      update-states
    ]
    
    if [distance myself] of one-of patches with [any? players-here] = 1    [
       user-message "YOU FAILED. Tank caught you"   toggleendgame ;; enemy tank has caught the player
    ]
  ]
  
  if enemy-can-shoot? = true
  [
    every(2.0)
    [
      Enemy-shoot
    ]
  ]
end


; move to next patch in patch
to move-to-next-patch-in-current-path
  ask bots 
  [
    face first current-path
    ;move-to first current-path
    ; if distance from this turtle to the player is less than range & clear line of sight, then
    ;if distance-to-player
  ]
end

to can-shoot-player ; bot procedure
  ask bots
  [
    ; check if the closest player is within firing range
    if (distance min-one-of players[distance myself] < range)
    [
      ; check if player is in LOS
      if player-in-LOS?
      [
        ; fire
      ]
    ]
  ]
end

to-report player-in-LOS? ; bot procedure
  ; if no obstacles between bot and player AND distance is within a certain range, then LOS is true
  ;report min-one-of players[distance myself] 'isInLOS'true/false
  report true
end

to find-shortest-path-to-destination
  reset-ticks
  ask bots 
  [
    set path find-a-path patch-here destination
    set optimal-path path
    set current-path path
  ]
  move-bot
end

to-report find-a-path [ source-patch destination-patch] 
  ; initialize all variables to default values
  let search-done? false
  let search-path []
  let current-patch 0
  set open []
  set closed []  
  
  ; add source patch in the open list
  set open lput source-patch open
  
  ; loop until we reach the destination or the open list becomes empty
  while [ search-done? != true ]
  [    
    ifelse length open != 0
    [
      ; sort the patches in open list in increasing order of their f() values
      set open sort-by [[f] of ?1 < [f] of ?2] open
      
      ; take the first patch in the open list
      ; as the current patch (which is currently being explored (n))
      ; and remove it from the open list
      set current-patch item 0 open 
      set open remove-item 0 open
      
      ; add the current patch to the closed list
      set closed lput current-patch closed
      
      ; explore the Von Neumann (left, right, top and bottom) neighbors of the current patch
      ask current-patch
      [         
        ; if any of the neighbors is the destination stop the search process
        ifelse any? neighbors4 with [ (pxcor = [ pxcor ] of destination-patch) and (pycor = [pycor] of destination-patch)]
        [
          set search-done? true
        ]
        [
          ; the neighbors should not be obstacles or already explored patches (part of the closed list)          
          ask neighbors4 with [ pcolor != red and (not member? self closed) and (self != parent-patch) ]     
          [
            ; the neighbors to be explored should also not be the source or 
            ; destination patches or already a part of the open list (unexplored patches list)
            if not member? self open and self != source-patch and self != destination-patch
            [
              if debug?
              [
                set pcolor 45
              ]
              
              ; add the eligible patch to the open list
              set open lput self open
              
              ; update the path finding variables of the eligible patch
              ; set the parent patch before we assess a new patch
              set parent-patch current-patch 
              ; set new distance
              set g [g] of parent-patch + 1
              ; calculate new estimate heuristic value
              
              ; heuristic function for seeking state
              ask myself [ 
                if [pcolor] of myself = white [ 
                  set h distance destination-patch 
                ] 
                if [pcolor] of myself = grey [
                  set h distance destination-patch + 3
                ]
              
              ]
              ;set h distance destination-patch + ([move-rate] of myself) - 5
             
              ; calculate patch value
              set f (g + h)
            ]
          ]
        ]
        if self != source-patch
        [
          if debug?
          [
            set pcolor 35
          ]
        ]
      ]
    ]
    [
      ; if a path is not found (search is incomplete) and the open list is exhausted 
      ; display a user message and report an empty search path list.
      user-message( "A path from the source to the destination does not exist." )
      report []
    ]
  ]
  
  ; if a path is found (search completed) add the current patch 
  ; (node adjacent to the destination) to the search path.
  set search-path lput current-patch search-path
  
  ; trace the search path from the current patch 
  ; all the way to the source patch using the parent patch
  ; variable which was set during the search for every patch that was explored
  let temp first search-path
  while [ temp != source-patch ]
  [
    ask temp
    [
      if debug?
      [
        set pcolor 85
      ]
    ]
    set search-path lput [parent-patch] of temp search-path 
    set temp [parent-patch] of temp
  ]
  
  ; add the destination patch to the front of the search path
  set search-path fput destination-patch search-path
  
  ; reverse the search path so that it starts from a patch adjacent to the
  ; source patch and ends at the destination patch
  set search-path reverse search-path  

  ; report the search path
  report search-path
end

; make the turtle traverse (move through) the path all the way to the destination patch
to move-bot
  ask bots 
  [
    if length current-path != 0
    [
      every 0.25
      [
        face first current-path
        move-to first current-path
        set current-path remove-item 0 current-path
        pd
        set current-bot-move-rate [move-rate] of patch-here 
      ]
    ]
    if length current-path = 0
    [
      pu
    ]
  
  ]   
end

;;;;;;;;;;;;;;;;;;;
;;enemy shooting ;;
;;;;;;;;;;;;;;;;;;;
to Enemy-shoot
  if (enemyAmmo > 0)
  [
    create-missiles 1 
    [
      setxy ([xcor] of bot 1) ([ycor] of bot 1)
      set shape "missile"
      set heading [heading] of bot 1
      set size 2.5
      set enemyAmmo enemyAmmo - 1
    ]
  ]
end

to Enemy-shoot-missiles
  ask missiles
  [
    fd 1
    if xcor >= 37 or xcor <= 0 or ycor >= 37 or ycor <= 0 [die]
    if [pcolor] of patch-here = red [die]
    if any? players-here
    [
      ask players-here
      [
        set playerHealth playerHealth - 25
        if (playerHealth = 0) 
        [
          explodePlayerAnimation
          sound:play-sound "tankDeath.wav"
          die
        ]
        if (playerHealth != 0)
        [
          damagePlayerAnimation
          sound:play-sound "tankTakeDamage.wav"
        ]
      ]
      ask missiles-here [die]
    ]
  ]
end


;;;;;;;;;;;;;;;;;;;;;
;;enemy animations ;;
;;;;;;;;;;;;;;;;;;;;;

to explodeEnemyAnimation
 ask bots [set shape "tank_dead_1"]
 wait 0.2
  ask bots [set shape "tank_dead_2"]
 wait 0.2
  ask bots [set shape "tank_dead_3"]
 wait 0.2
  ask bots [set shape "tank_dead_2"]
 wait 0.2
  ask bots [set shape "tank_dead_1"]
 wait 0.2
 ask bots [set shape "tank_dead"]
end

to damageEnemyAnimation
   ask bots [set shape "tank_dead_1"]
 wait 0.2
   ask bots [set shape "tank_dead_2"]
 wait 0.2
    ask bots [set shape "tank_dead_1"]
 wait 0.2
  ask bots [set shape "tank"]
end